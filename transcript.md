# Free Security for Open-Source Software - Transcript

Hello everyone!  It's good to be back on day two of SeaGL, and today I am talking to you about Free Security for Open-Source Projects.  If you want to follow along with the sources that I used to put together this talk as I'm speaking, you can go to the Github link on the slide at the moment, or scan the QR code with your phone, and it will bring you to a Github repository with all of the sources that I used.

To begin with, I would like to acknowledge the Wurundjeri people of the Kulin Nation, on whose land this talk was recorded, and all other Aboriginal and Torres Strait Islander groups across Australia.  This is, and always will be, Aboriginal land.  Their sovereignty was never ceded.  I would also like to acknowledge the Aboriginal and Torres Strait Islander mentors that I had growing up, who played a formative role in who I am today.

So, who am I?  My name is Dawn, and I am a security and DevOps person at Innablr.  We're a boutique consultancy in Melbourne, Australia, and we like to solve DevOps problems, so- if you like to solve DevOps problems too, we're hiring, or if you're looking for someone to solve those problems for you, come and find me and I can put you in touch with the right people.  I am also an open-source enthusiast, and one of the reasons that I really enjoy working at Innablr is that they're supporting me to be an open-thource- source enthusiast.  Outside of work, I am an occasional author and kitchen alchemist - sometimes that ends really well, sometimes it doesn't.  I'm also a raging sportsball fan, which is why - sorry Seattle - that's me in a Boston Bruins sweater.

So, talking about security in open-source -  I mean, security in general kind of comes down to a question of design.  And - there is no one overarching design for free and open-source software.  It spans everything from the packages that we use when we use a library like React or Ruby on Rails, or the packages that we use when we build small applications ourselves.  And then it goes- everything to, ElasticSearch, erm, full-featured tools like LibreOffice, and a bunch of web tools for all kinds of things.  So - the way that you interact with the security ecosystem, and the way that you use security practices and security tools, will depend very much on what it is that you're actually building.  And, that kind of comes down to - I guess if we have to split it, there's probably one big split that we can have here.  And that's open-source packages, compared to feature-complete open-source software.  Two workflows, similar in some aspects but different in others, and those are the two, sort of, main workflows that you'll find around security in open-source software.

So let's take a moment, and put on our black hats, and think about how we would actually breach a system.  There are a few different ways to breach a system that cut across both of those different types of open-source software.  Ah, supply chain attacks are always a really obvious one.  Unless you are building a very very core package that does not rely on anything else, there is always a possibility that someone will be able to attack your application - nn, by attacking an upstream dependency.  Then we've got stuff like malicious code injection; if someone can manage to get nasty code into your application, well, jackpot for them, and game's probably over for you, because at that point they can breach everyone who's downloaded your package or all of your users.  Phishing and social engineering attacks are another fairly critical one for open-source in particular, because you're only as secure as the least secure person that's got privileges to your code.  And there are many, many more ways to breach a system.  We'll cover some of them later on, but these are kind of the- core ways that you can breach a system that will apply to a lot of open-source.

So, let's look at attacks that have actually happened.  Er, the ESLint one was a really good one; I'm sure that anyone who's worked with Javascript probably remembers that.  Ah, what happened was that one of the ESLint maintainers had been using the same credentials that they had used elsewhere, and those credentials had been breached, which were up- uploaded- probably in some s- data dump somewhere, which resulted to that maintainer's token being compromised.  And what the attacker did was really clever; they actually uploaded in some of the - not ESLint Core, but some of the other packages that were maintained by ESLint - a credential stealer.  So it would go in, it would sniff your `.npmrc` file, and it would hoover up whatever credentials it could find in there and send them off somewhere else.  Then there was the, ah, RubyGems attack.  And this wasn't just one package, this was several packages all at once.  Now, if you went and you installed those Ruby gems, you got some free extra software - erm, quite a bit of malware, and - crypto wallets and crypto miners were installed with these packages.  So that's nice, you get extra stuff for free, the fact that it's taking up a lot of your CPU cycles then notwithstanding.  Er, another really common one - and again, this is not one breach but more than one - is the ElasticSearch breaches, and these tend to happen fairly regularly.  Now ElasticSearch itself, and Elastic- the cloud- ah, maintained version of ElasticSearch are not awful in security, but - it's really really easy to- easy to misconfigure ElasticSearch.  And so there have been a bunch of cases where organisations have been breached, and they've actually blamed those breaches specifically on [laughter] misconfigurations in their Elastic setups that have meant that someone's basically been able to go in and yoink all of their personal data.

And part of defending against these sorts of attacks is about actually thinking like a malicious actor.  So if you wanted to breach your particular open-source project, what possible attack vectors might you use?  So we've talked about a few; things like phishing, you know, social engineering, injecting malicious code, being able to compromise a package upstream, but the other question then is which are the most likely to succeed?  And that's going to depend entirely on the package.  If you're producing a feature-complete- piece of open-source software then the types of attacks that are the most likely to succeed are going to be completely different to the types of attacks that are going to succeed on an upstream package that's designed to be consumed.

But - one thing that cuts across all packages, you know, all types of open-source software, again, is that often people are the weak point.  So you've got to think about things like - are we giving elevated permission to anyone that we shouldn't be?  As we've seen from the ESLint attack, if you're not careful about that kind of thing, you know, the more people that you give elevated permissions to, the more risk you introduce.  And it's also worth here thinking about, ah, other applications or upstream dependencies that you might be relying on, and - whether you, you know, how secure are they, but also whether you've actually given them appropriate permissions or whether they could see far more than they should be able to.  And then there's the old question of how hard would it be for someone to execute a phishing or social engineering attack on the project's core team?  Because, if - someone is able to do that, then very quickly, they can potentially get access to a hell of a lot of information about what is going on with your project.

So I know that this is, ah, 'Free Security For Open-Source Software', and the abstract does talk about tools, but let's start by talking about free security that you can get without ever touching an external tool.  And that comes down to - a concept that I'm going to - describe as end-to-end system hardening.  And really, a lot of this is about removing the- credential compromise piece, and removing the social engineering piece.  And as I said before, proper access management is a really critical part of this.  But once you're sure that everyone has the exact amount of access that they should - just in time and just enough are two concepts that are really good to look at for this - erm, then you've got to start thinking about how you actually defend against some of these attacks.

So, password hygiene is a really important thing.  Don't reuse passwords; if you possibly can, use a password manager, because then it means you only have to remember one password, and if you need to, you know, if someone gets breached, and you need to generate a new secure password, that's pretty trivial.  And to recognise when breaches are coming down the pipeline, leveraging tools like Have I Been Pwned is really good for this.  So - making sure that you're actually subscribed to alerts on your email addresses, subscribe to Have I Been Pwned alerts, and that you're checking to make sure that your passwords have never been in data breaches.  Another thing that tends to guard against problems even if you don't have perfect password hygiene is multi-factor authentication.  Now hardware keys like YubiKeys are the holy grail of this - you actually have to have the hardware key on your person, stick it into a machine, and press a button - but even setting up multi-factor authentication with- something like a mobile phone, even with SMS, is vastly preferable to having no multi-factor authentication on there at all.  Because if someone is to guess your password, or if someone is to breach your password, then having multi-factor authentication in there will stop them unless they've also got access to the corresponding piece of hardware.

And another thing that's important is rolling tokens regularly.  Not just access tokens or passwords that you use, but also tokens that your project might use to authenticate to other projects or other services.  Making sure that  - very often, you know, actually set yourself a schedule and go in and roll those tokens, so that if they do get compromised, people will only get access for a certain amount of time before it get cuts off [sic].

And, doing the end-to-end security piece really well does have a time cost.  So there is - you know, it takes time to do this properly, but the thing about it is is that once you do this properly and you get into the habit, it really will protect you against a lot of the potential security issues that you can run into.

Another thing that's important to think about in terms of free security without third-party tools is - using secure platforms.  And so this is about, if you have to pick a hosting platform, or if you have to pick a third-party to interact with, try to find a third-party that manages security for you, rather than leaving it to you.  In the commercial world, Kubernetes is kind of notorious for this, because it's not secure out of the box; there's actually a decent amount of work that you have to put in to get a Kubernetes set up to be secure, and so a lot of people get caught out that way.  And as far as open-source goes, there are some really good ones.  Erm, Github has a dependency management tool built into itself called Dependabot, which will warn you if there are any known CVEs in your upstream dependencies, and will actually put in pull requests to your project to update them yourself if it possibly can.  Another really good thing that Github does is it actually has the concept of code owners for files, so you're able to put in, sort of, ah, boundaries around the code in your project to say, these particular people need to look at these- changes to these particular files, and when someone puts in a pull request - then the people that you've nominated as code owners will be automatically - er, they'll automatically be marked for review- marked as reviewers on that pull request.

So Github has done a lot of good stuff ab- around security, but Gitlab has as well, except that what they've done, a lot of that has been in the realm of CI and CD.  So - their CI/CD system, they have actually spent a lot of time integrating free and open-source security tools into it, with the idea that then you can - turn all of those tools on in their CI/CD, without having to- go to any extra effort; they're doing a lot of that work for you and abstracting it away.  Another interesting thing to think about, if you've got to host an application somewhere, is - rather than just pulling down whatever the latest release of Ubuntu or Debian is, you can look into hosting things on- Linux distributions with hardened kernels that are specifically designed to be secure, or hosting things on stripped-down Linux versions, er, Linux distros that have a lot less bloat in them, and that means they also have fewer attack vectors.  And in terms of the secrets management piece, it's always good to look for platforms that will do secrets management for you, or to look for platforms that do secrets management well, rather than you having to go away and do a lot of that secrets management work yourself.  So if you're looking for a, say a CI/CD provider, make sure that they have features to store your secrets, and make sure that those features actually keep your secrets secure, and that they're not being leaked as a result of that.

So that then brings us to - what some might consider the crux of this talk, which is the free security tooling.  Now - there is a huge amount of free security tooling out there, and it falls into broadly, two different categories.  The first one is security tooling that's actually open-source itself.  And there are a lot of applications there.  The second one - is security tooling that while it is closed-source and is typically paid for, has actually presented itself as being free for open-source projects.  So let's look at the open-source security tooling first.  In terms of static application security testing and dynamic application security testing, there are way too many for me to detail here.  But the OWASP project actually maintains a list of SAST and DAST tools - it's in the sources - and although it includes both commercial and open-source tools, it specifically highlights the open-source tools as being open-source.  It also has some degree of highlighting where things are free for open-source.  So definitely go away, if you're interested in the application security testing piece, definitely go away and have a look at all of those tools.

Now if you are hosting anything in the cloud, another important thing to look at then, is actually scanning your infrastructure as code.  And there are a couple of different open-source tools for that; one that I've used really extensively is Checkov, which deals with - all of the big cloud providers, and also scans Kubernetes stuff, but if you're looking specifically at Terraform, then there's Terrafirma, which is designed as a security scanner specifically for Terraform.  There are other options for IaC scanning, but those two are probably going to cover off the vast majority of what you would need.

Then wi- another thing that we can look at here is image scanning, and for image scanning, hands down the best option is Clair.  So Clair will basically go through, it will scan any Docker images that you are using as part of your project, and it will let you know if there are any vulnerabilities in them.  And it's also configurable, so you can go ahead and tell it exactly what level of vulnerabilities you want to look at, get it to ignore vulnerabilities- like many other tools it can be built into your pipeline.  Dependency management is another fairly important piece and we've talked about dependable already, but OWASP has actually released some tools for this themselves.  They've got Dependency Check and Dependency Track; slightly different use cases, but between the two of them, that will cover a lot of the potential issues that you might run into around dependency management.  There are also a bunch of other tools that don't quite fit into any of these categories, and I want to highlight specifically three here, which are not necessarily going to be as useful to you if you're building a package, but will probably be useful to you if you're building feature-complete software.  So the OWASP ZAP is a pen testing tool - an open-source pen testing tool - and, that will run against a lot of common CVEs, and a lot of really common attack vectors.  If you're doing anything web-based, then Wireshark is an open-source tool that allows you to do packet scanning, so you can see if there's anything going on that looks atypical.  And if you really want to go the whole hog with pen-testing then there's Kali Linux, which is- a Linux distribution that is entirely focused around penetration testing, and it comes with a bunch of really good pen-testing tools.  These, unlike a lot of the ones that we talked about earlier, are not going to be for everyone - but if you're building feature-complete software, they're useful to have in your arsenal.

Now the thing with closed-source tools that are free for open-source is there are a huge amount of them, but there are two that I want to focus on specifically.  For different reasons.  The first one is Snyk.  And the reason why I want to look at Snyk's suite of tools is because - even though it's closed-source, it's actually a pretty comprehensive set of tools that you can get for them, that are all f- effectively, free for open-source.  They - obviously don't provide you with support around that, but if you do want to use those tools, they're there, and they're free for open-source.  And having all of that in one place can save you the difficulty of having to go and pick specific open-source tools to help you manage different parts of your security.  The other one that I want to look at is Debricked, for the very specific reason that if you look at the tools that OWASP recommends, Debricked has one of the highest true positive rates and one of the lowest false positive rates of - basically, scanning tools that are out there.  So if you're looking for something accurate, the fact that Debricked is free for open-source is really good for you there, because it actually enables you to go in and be fairly confident that the alerts that you're getting - are, alerting on actual problems, which saves you from potentially having to go down rabbit holes around solving issues that aren't really issues.

So we've come to the end of the talk now, and before we finish up, I want to briefly talk about- come back to that sort of idea that we talked about at the beginning, of packages compared to feature-complete software.  Because where you do or do not integrate a lot of these tools into your workflow is going to depend on what you're actually building. The other thing is that - the potential set of people who can be compromised differs depending on what you're building as well.  So, take some time to think about - put yourself in the shoes of a malicious user, and think about, if you wanted to attack your piece of software, how would you go about it?  So we now have some time for questions.  If there's anything that I don't get to, then you can contact me on the contacts that are up on the screen now.  Thank you for coming along and listening to me talk about free security for open-source projects, and I am very much hoping to hear about a lot of you using these free security tools in the future.  Thank you.

[Back to Free Security for Open-Source Projects](.)
